<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>以太坊是什么</title>
    <link href="/2019/11/02/block_chain/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2019/11/02/block_chain/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="以太坊是什么"><a href="#以太坊是什么" class="headerlink" title="以太坊是什么"></a>以太坊是什么</h2><p>以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p><blockquote><p>对这句话不理解的同学，姑且可以理解为以太坊是区块链里的 Android，它是一个开发平台，让我们就可以像基于 Android Framework 一样基于区块链技术写应用。</p></blockquote><p>在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。</p><p>以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，只要专注于开发应用本身逻辑的智能合约，这样就可以大大降低开发难度。</p><blockquote><p>目前围绕以太坊已经形成了一个最为完善的开发生态：有很多经过测试和验证的开发库、有完善的<a href="https://learnblockchain.cn/docs/">开发者文档</a>（中文的也很多）及开发测试工具。</p></blockquote><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>那么什么是智能合约呢？<strong>以太坊网络上运行程序就称之为智能合约</strong>， 它和其他的程序一样，也是代码和数据 (状态) 的集合。</p><p>智能合约（Smart Contract）和人工智能（Artificial Intelligence ）的智能没有关系，智能合约最早尼克萨博在 95 年就提出，它的概念很简单，就是将法律条文写成可执行代码。让法律条文的执行中立化，这个理念和区块链上的程序可以不被篡改、不被干预（只有有人触发交易，它将自动执行）的执行不谋而合，因此区块链引入了这个概念。</p><p>在前面介绍<a href="https://learnblockchain.cn/2017/11/10/bitcoin-script/">比特币脚本</a>的时候，我们讲到过比特币的交易也是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊程序则是 “图灵完备的”，因此理论上让我们可以来编写可以做任何事情的程序。</p><p>智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。<br>目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信 1 到 3 年内，各种杀手级会慢慢出现。</p><p>进一步了解智能合约，可以阅读<a href="https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/">完全了解智能合约运行原理</a>。</p><h3 id="编程语言：Solidity"><a href="#编程语言：Solidity" class="headerlink" title="编程语言：Solidity"></a>编程语言：Solidity</h3><p>智能合约现在的主要编程语言是 <a href="https://learnblockchain.cn/docs/solidity/">Solidity</a> 和 Vyper ，<code>Solidity</code> 更为成熟一些，<code>Solidity</code> 合约文件扩展名是 <code>.sol</code> ，虽然是一门新语言，但是但是他和大家常用的现代语言很相似，学期来 以下就是一个简单的计数器智能合约：</p><figure class="highlight d"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity &gt;=<span class="hljs-number">0.4</span><span class="hljs-number">.22</span> &lt;<span class="hljs-number">0.6</span><span class="hljs-number">.0</span>;<br> <span class="hljs-comment">// 用contract 关键字定义一个合约</span><br>contract Counter &#123; <br>    <span class="hljs-built_in">uint</span> counter;<br><br>    <span class="hljs-built_in">function</span> count() <span class="hljs-keyword">public</span> &#123;<br>        counter = counter + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果上面的合约把 <code>contract</code> 改成 <code>class</code> ，就和其他语言里定义一个类一样了。 <code>Solidity</code> 是一门编译型语言，代码被编译为以太坊虚拟机字节码之后，再部署到以太坊网络。以太坊为我们提供了很好的工具来完成这项工作，比如：<a href="https://remix.ethereum.org/">Remix</a> 就是用来开发、编译、部署智能合约的 IDE，它还是一个基于浏览器的 Web IDE，下面是 Remix IDE 的一个截图。<br><img src="https://img.learnblockchain.cn/2019/06/15613593398072.jpg" alt="Remix IDE"></p><p>Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。 了解更多 Solidity 知识，可以参考社区翻译的 <a href="https://learnblockchain.cn/docs/solidity/">Solidity 中文文档</a>。</p><h3 id="运行环境：EVM"><a href="#运行环境：EVM" class="headerlink" title="运行环境：EVM"></a>运行环境：EVM</h3><p>EVM（Ethereum Virtual Machine）<a href="https://learnblockchain.cn/2019/04/09/easy-evm/">以太坊虚拟机</a> 用来执行以太坊上的交易，提供智能合约的运行环境。</p><blockquote><p>Solidity 之于 EVM，就像之于跟 JVM 的关系一样，这样大家就容易理解了。<br><a href="https://learnblockchain.cn/2019/04/09/easy-evm/">以太坊虚拟机</a>是一个隔离的环境，外部无法接触到在 EVM 内部运行的代码。</p></blockquote><p>而 EVM 运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。</p><h3 id="合约的编译"><a href="#合约的编译" class="headerlink" title="合约的编译"></a>合约的编译</h3><p>以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择 <a href="https://remix.ethereum.org/">Remix</a> 或 solc 编译器。</p><h3 id="合约的部署"><a href="#合约的部署" class="headerlink" title="合约的部署"></a>合约的部署</h3><p>在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？</p><h4 id="以太坊客户端（钱包）"><a href="#以太坊客户端（钱包）" class="headerlink" title="以太坊客户端（钱包）"></a>以太坊客户端（钱包）</h4><p>以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。</p><blockquote><p>EVM 是由以太坊客户端提供的</p></blockquote><p><strong>Geth</strong> 是典型的开发以太坊时使用的客户端，基于 Go 语言开发。 <code>Geth</code> 提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth 的使用我们之后会有文章介绍，这里大家先有个概念。</p><blockquote><p>Geth 控制台和 Chrome 浏览器开发者工具里的面的控制台是类似的，不过 Geth 控制台是跑在终端里。</p></blockquote><h4 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h4><p>智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。</p><blockquote><p>以太坊中有两类账户：</p><ul><li>外部账户<br>该类账户被私钥控制（由人控制），没有关联任何代码。</li><li>合约账户<br>该类账户被它们的合约代码控制且有代码与之关联。</li></ul><blockquote><p>和比特币使用 UTXO 的设计不一样，以太坊使用更为简单的账户概念。<br>两类账户对于 EVM 来说是一样的。</p></blockquote><p>外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。<br>在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。<br>只有当外部账户发出指令时，合同账户才会执行相应的操作。</p></blockquote><p>合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。</p><h2 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h2><p>和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对！）。</p><p>以太坊上用 Gas 机制来计费，Gas 也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多 Gas。</p><p>任何特定的合约所需的运行合约的 Gas 数量是固定的，由合约的复杂度决定。<br>而 Gas 价格由运行合约的人在提交运行合约请求的时候设定，以确定他愿意为这次交易愿意付出的费用：Gas 价格（用以太币计价） * Gas 数量。</p><p>Gas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有 Gas 剩余，这些 Gas 将被返还给发送账户。</p><blockquote><p>如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。</p></blockquote><p>因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。</p><h2 id="以太坊网络"><a href="#以太坊网络" class="headerlink" title="以太坊网络"></a>以太坊网络</h2><p>有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式：</p><h3 id="选择以太坊官网测试网络-Testnet"><a href="#选择以太坊官网测试网络-Testnet" class="headerlink" title="选择以太坊官网测试网络 Testnet"></a>选择以太坊官网测试网络 Testnet</h3><p>测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。</p><h3 id="使用私有链"><a href="#使用私有链" class="headerlink" title="使用私有链"></a>使用私有链</h3><p>创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。<br>通过上面提到的 Geth 很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。</p><h3 id="使用开发者网络-模式"><a href="#使用开发者网络-模式" class="headerlink" title="使用开发者网络 (模式)"></a>使用开发者网络 (模式)</h3><p>相比私有链，开发者网络 (模式) 下，会自动分配一个有大量余额的开发者账户给我们使用。</p><h3 id="使用模拟环境"><a href="#使用模拟环境" class="headerlink" title="使用模拟环境"></a>使用模拟环境</h3><p>另一个创建测试网络的方法是使用 Ganache，Ganache 是普通的应用程序，它在本地使用内存模拟的一个以太坊区块链环境，对于开发调试来说，更方便快捷。而且 Ganache 会在启动时帮我们创建 10 个存有资金的测试账户。<br>进行合约开发时，可以在 Ganache 中测试通过后，再部署到 Geth 节点中去。</p><h2 id="DApp：去中心化的应用程序"><a href="#DApp：去中心化的应用程序" class="headerlink" title="DApp：去中心化的应用程序"></a>DApp：去中心化的应用程序</h2><p>以太坊社区把基于智能合约的应用称为去中心化的应用程序 (Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了，一个 DApp 不单单有智能合约（相当于应用的后台），比如还需要有一个友好的用户界面。</p><h3 id="Truffle"><a href="#Truffle" class="headerlink" title="Truffle"></a>Truffle</h3><p><a href="https://learnblockchain.cn/docs/truffle/">Truffle</a> 是一个非常流行 DApp 开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码 - 编译 - 部署 - 测试 - 打包 DApp 这个流程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用 Solidity 来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用 <a href="https://learnblockchain.cn/docs/truffle/">Truffle</a> 可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用 Geth 或 Ganache 来搭建一个测试网络。</p><p>注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。</p>]]></content>
    
    
    <categories>
      
      <category>block_chain</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>智能合约雏形</title>
    <link href="/2019/11/02/block_chain/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%8F%E5%BD%A2/"/>
    <url>/2019/11/02/block_chain/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E9%9B%8F%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p>大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。<br>在比特币区块链中，交易不是这么简单，交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种 “可编程的货币”。<br>本文就来分析一下交易是如何实现可编程的。</p><h2 id="未花费的交易输出-UTXO"><a href="#未花费的交易输出-UTXO" class="headerlink" title="未花费的交易输出 (UTXO)"></a>未花费的交易输出 (UTXO)</h2><p>先引入一个概念：未花费的交易输出 ——UTXO（Unspent Transaction Output）</p><p>其实比特币的交易都是基于 UTXO 上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。</p><blockquote><p>挖矿奖励属于一个特殊的交易（称为 coinbase 交易），可以没有输入。<br>UTXO 是交易的基本单元，不能再分割。<br>在比特币没有余额概念，只有分散到区块链里的 UTXO</p></blockquote><p>随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样：<br><img src="https://img.learnblockchain.cn/2017/own_chain.jpeg!wl" alt="own_chain"></p><h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p>比特币交易是首先要提供一个用于解锁 UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，<br>交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。</p><p>每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。</p><blockquote><p>当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真</p></blockquote><p>如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样：<br><img src="https://img.learnblockchain.cn/2017/script.jpeg!wl" alt="script"></p><h3 id="常见交易脚本验证过程"><a href="#常见交易脚本验证过程" class="headerlink" title="常见交易脚本验证过程"></a>常见交易脚本验证过程</h3><p>比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。</p><blockquote><p>比特币脚本语言包含基本算数计算、基本逻辑 (比如 if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考: <a href="http://www.8btc.com/bitcoin_scripts">比特币脚本</a></p></blockquote><p>脚本语言通过从左至右地处理每个项目的方式执行脚本。</p><p>下面用两个图说明下常见类型的比特币交易脚本验证执行过程：<br><img src="https://img.learnblockchain.cn/2017/script_run1.jpeg!wl" alt="script_run1"><br>上图为解锁脚本运行过程（主要是入栈）<br><img src="https://img.learnblockchain.cn/2017/script_run2.jpeg!wl" alt="script_run2"><br>上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。</p><h2 id="交易分析"><a href="#交易分析" class="headerlink" title="交易分析"></a>交易分析</h2><p>实际上比特币的交易被设计为可以纳入多个输入和输出。</p><h3 id="交易结构"><a href="#交易结构" class="headerlink" title="交易结构"></a>交易结构</h3><p>我们来看看完整的交易结构，<br><img src="https://img.learnblockchain.cn/2017/tx_struce.jpeg!wl" alt="img"></p><blockquote><p>交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成 0，用来表示立即执行。<br>如果锁定时间不是 0 并且小于 5 亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。<br>如果锁定时间大于 5 亿，则它被当作是一个 Unix 纪元时间戳（从 1970 年 1 月 1 日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。</p></blockquote><p>交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：</p><blockquote><p>交易费 = 求和（所有输入） - 求和（所有输出）</p></blockquote><h3 id="交易输入结构"><a href="#交易输入结构" class="headerlink" title="交易输入结构"></a>交易输入结构</h3><p>刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构：<br><img src="https://img.learnblockchain.cn/2017/tx_input_struce.jpeg!wl" alt="img"></p><p>我们结合整个交易的结构里看输入结构就是这样子：<br><img src="https://img.learnblockchain.cn/2017/tx_input_overview.jpeg!wl" alt="img"></p><h3 id="交易输出结构"><a href="#交易输出结构" class="headerlink" title="交易输出结构"></a>交易输出结构</h3><p>刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：<br><img src="https://img.learnblockchain.cn/2017/tx_output_struce.jpeg!wl" alt="img"><br>我们结合整个交易的结构里看输出结构就是这样子：<br><img src="https://img.learnblockchain.cn/2017/tx_output_overview.jpeg!wl" alt="img"></p><h3 id="交易哈希计算"><a href="#交易哈希计算" class="headerlink" title="交易哈希计算"></a>交易哈希计算</h3><p>在<a href="https://xiaozhuanlan.com/topic/1402935768">比特币区块结构 Merkle 树及简单支付验证分析</a> 讲到区块结构，区块结构包含多个交易的哈希。<br>那么交易哈希是怎么计算的呢？</p><ol><li>交易结构各字段序列化为字节数组</li><li>把字节数组拼接为支付串</li><li>对支付串计算两次 SHA256 得到交易 hash</li></ol><p>了解详情可进一步参考<a href="https://bitcoin.stackexchange.com/questions/2859/how-are-transaction-hashes-calculated">如何计算交易 Hash?</a> 及<a href="https://bitcointalk.org/index.php?topic=54451.msg649253#msg649253">如何创建 Hash?</a></p><p>现在是不是对完整的交易到区块有了更清晰的认识。</p><h2 id="智能合约雏形-应用场景说明"><a href="#智能合约雏形-应用场景说明" class="headerlink" title="智能合约雏形 - 应用场景说明"></a>智能合约雏形 - 应用场景说明</h2><p>由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。</p><p>比特币的脚本目前常用的主要分为两种，一种是常见的 P2PKH（支付给公钥哈希），另一种是 P2SH（Pay-to-Script-Hash 支付脚本哈希）。<br>P2SH 支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付 UTXO 时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。</p><p>这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。</p><ul><li><p>多重签名应用<br>合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。</p><p>用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。</p></li><li><p>保证合同<br>保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。<br>一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。</p></li><li><p>依靠预言<br>假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满 18 岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。<br>因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>block_chain</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么要遵守协议</title>
    <link href="/2019/11/02/block_chain/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%B5%E5%AE%88%E5%8D%8F%E8%AE%AE/"/>
    <url>/2019/11/02/block_chain/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%B5%E5%AE%88%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？</p><h2 id="为什么要遵守协议"><a href="#为什么要遵守协议" class="headerlink" title="为什么要遵守协议"></a>为什么要遵守协议</h2><p>这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，<br>而只有遵守规则才会得到其他的节点认同。<br>因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。</p><blockquote><p>共识：共同遵守的协议规范</p></blockquote><h2 id="去中心化共识"><a href="#去中心化共识" class="headerlink" title="去中心化共识"></a>去中心化共识</h2><p>在<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">工作量证明</a>一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，<br>实际上，比特币的共识由所有节点的 4 个<strong>独立过程</strong>相互作用而产生：</p><ol><li>每个节点（挖矿节点）依据标准对每个交易进行独立验证</li><li>挖矿节点通过完成工作量证明，将交易记录独立打包进新区块</li><li>每个节点独立的对新区块进行校验并组装进区块链</li><li>每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链</li></ol><p>共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。</p><p>第 1 2 3 步在<a href="https://learnblockchain.cn/2017/11/04/bitcoin-pow/">比特币如何挖矿 - 工作量证明</a>一篇有提到过，下面着重讲第 4 步。</p><h2 id="最长链的选择"><a href="#最长链的选择" class="headerlink" title="最长链的选择"></a>最长链的选择</h2><p>先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为<strong>主链</strong><br>每一个（挖矿）节点总是选择并尝试延长主链。</p><h3 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h3><p>当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的 “获胜” 区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。<br>当这个两个区块传播时，一些节点首先收到 #3458A, 一些节点首先收到 #3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：<br><img src="https://img.learnblockchain.cn/2017/block_branch.jpg!wl" alt="img"><br>两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为<strong>备用链</strong>保存（保存是因为备用链将来可能会超过主链难度称为新主链）。</p><h3 id="分叉解决"><a href="#分叉解决" class="headerlink" title="分叉解决"></a>分叉解决</h3><p>收到 #3458A 的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受 #3458B 区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为 B 链）。<br>这时总会有一方抢先发现工作量证明解并将其传播出去，假设以 #3458B 为父区块的工作量证明首先解出，如图：<br><img src="https://img.learnblockchain.cn/2017/block_branch2.jpg!wl" alt="img"></p><p>当原本以 #3458A 为父区块求解的节点在收到 #3458B, #3459B 之后，会立刻将 B 链作为主链（因为 #3458A 为顶点的链已经不是最长链了）继续挖矿。</p><blockquote><p>节点也有可能先收到 #3459B，再收到 #3458B，收到 #3459B 时，会被认为是 “孤块 “（因为还找不到 #3459B 的父块 #3458B）保存在孤块池中，一旦收到父块 #3458B 时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</p></blockquote><p>比特币将区块间隔设计为 10 分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。</p>]]></content>
    
    
    <categories>
      
      <category>block_chain</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么要记账</title>
    <link href="/2019/11/02/block_chain/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%B0%E8%B4%A6/"/>
    <url>/2019/11/02/block_chain/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%B0%E8%B4%A6/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://learnblockchain.cn/2017/10/25/whatbc/">区块链记账原理</a> 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个 Hash 值等信息计算 Hash 打包的过程。<br>我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为 “挖矿”，本文将详细讨论这个过程。</p><h2 id="记账工作"><a href="#记账工作" class="headerlink" title="记账工作"></a>记账工作</h2><p>由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是 12.5 比特币，博文写作时每个比特币是 4 万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：</p><ul><li>一段时间内（10 分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功</li><li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li><li>其他节点复制记账结果</li></ul><p>不过在进行工作量证明之前，记账节点会做进行如下准备工作：</p><ul><li>收集广播中还没有被记录账本的原始交易信息</li><li>检查每个交易信息中付款地址有没有足够的余额</li><li>验证交易是否有正确的签名</li><li>把验证通过的交易信息进行打包记录</li><li>添加一个奖励交易：给自己的地址增加 12.5 比特币</li></ul><p>如果节点争夺记账权成功的话，就可以得到 12.5 比特币的奖励。</p><h2 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h2><p>区块链记账原理</p><p>我们了解到，每次记账的时候会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash。 如果仅仅是这样，显然每个人都可以很轻松的完成记账。 为了保证 10 分钟左右只有一个人可以记账，就必须要提高记账的难度，使得 Hash 的结果必须以若干个 0 开头。同时为了满足这个条件，在进行 Hash 时引入一个随机数变量。 用伪代码表示一下：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(上一个Hash值，交易记录集)</span></span> = <span class="hljs-number">456635</span>BCD<br><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(上一个Hash值，交易记录集，随机数)</span></span> = <span class="hljs-number">0000</span>aFD635BCD<br></code></pre></div></td></tr></table></figure><p>我们知道改变 Hash 的原始信息的任何一部分，Hash 值也会随之不断的变化，因此在运算 Hash 时，不断的改变随机数的值，总可以找到一个随机数使的 Hash 的结果以若干个 0 开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。</p><h3 id="计算量分析"><a href="#计算量分析" class="headerlink" title="计算量分析"></a>计算量分析</h3><p>（这部分可选阅读）我们简单分析下记账难度有多大，<br>Hash 值是由数字和大小写字母构成的字符串，每一位有 62 种可能性（可能为 26 个大写字母、26 个小写字母，10 个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为 0 的概率是 1/62（其他位出现什么字符先不管），理论上需要尝试 62 次 Hash 运算才会出现一次第一位为 0 的情况，如果前两 2 位为 0，就得尝试 62 的平方次 Hash 运算，以 n 个 0 开头就需要尝试 62 的 n 次方次运算。我们结合当前实际区块 #493050 信息来看看：</p><p><img src="https://img.learnblockchain.cn/2017/block_info_493050.jpg!wl" alt="区块#493050"></p><p>注：数据来源于 <a href="https://blockchain.info/">https://blockchain.info</a><br>我们可以看到 Hash 值以 18 个 0 开头，理论上需要尝试 62 的 18 次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，<br>目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。</p><p>从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。</p><p>题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在节点成功找到满足的 Hash 值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。</p><p>如果验证通过，则表明已经有节点成功挖出区块，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。<br>网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。</p><p>假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。</p><p>进阶阅读<a href="https://xiaozhuanlan.com/topic/1402935768">比特币区块结构 Merkle 树及简单支付验证分析</a>，可以详细了解区块结构如何验证交易。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>矿工的收益其实不仅仅包含新发行的 12.5 比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。</p>]]></content>
    
    
    <categories>
      
      <category>block_chain</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区块链记账原理</title>
    <link href="/2019/11/02/block_chain/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AE%B0%E8%B4%A6%E5%8E%9F%E7%90%86/"/>
    <url>/2019/11/02/block_chain/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AE%B0%E8%B4%A6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>区块链 (1.0) 是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。<br>通常认为与智能合约相结合的区块链为区块链 2.0, 如以太坊是典型的区块链 2.0<br>很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。<br>本文将讲解区块链 1.0 技术是如何实现的。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>在讲区块链记账之前，先说明一下哈希函数。<br>哈希函数：Hash (原始信息) = 摘要信息<br>原始信息可以是任意的信息，hash 之后会得到一个简短的摘要信息</p><p>哈希函数有几个特点:</p><ul><li>同样的原始信息用同一个哈希函数总能得到相同的摘要信息</li><li>原始信息任何微小的变化都会哈希出面目全非的摘要信息</li><li>从摘要信息无法逆向推算出原始信息</li></ul><p>举例说明：<br>Hash (张三借给李四 100 万，利息 1%，1 年后还本息 …..) = AC4635D34DEF<br>账本上记录了 AC4635D34DEF 这样一条记录。</p><p>可以看出哈希函数有 4 个作用：</p><ul><li>简化信息<br>很好理解，哈希后的信息变短了。</li><li>标识信息<br>可以使用 AC4635D34DEF 来标识原始信息，摘要信息也称为原始信息的 id。</li><li>隐匿信息<br>账本是 AC4635D34DEF 这样一条记录，原始信息被隐匿。</li><li>验证信息<br>假如李四在还款时欺骗说，张三只借给李四 10 万，双方可以用 AC4635D34DEF 来验证原始信息</li></ul><p>哈希函数的这 4 个作用在区块链技术里有广泛的运用。<br>（哈希函数是一组函数或算法，以后会发文章专门介绍哈希）</p><h2 id="区块链记账方法"><a href="#区块链记账方法" class="headerlink" title="区块链记账方法"></a>区块链记账方法</h2><p>假设有一个账页序号为 0 的账页交易记录如下:</p><table><thead><tr><th>账号</th><th>入账</th><th>出账</th><th>余额</th><th>备注说明</th></tr></thead><tbody><tr><td>王二</td><td>100</td><td></td><td>190</td><td>收到 xxx 货款</td></tr><tr><td>张三</td><td></td><td>100</td><td>30</td><td>xxxx</td></tr><tr><td>李四</td><td>120</td><td>90</td><td>170</td><td>xxxx</td></tr></tbody></table><p>记账时间为：2017-10-22 10:22:02</p><p>区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行 Hash, 得到一个 Hash 值，如：787635ACD, 用函数表示为：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(序号<span class="hljs-number">0</span>、记账时间、交易记录)</span></span> = <span class="hljs-number">787635</span>ACD<br></code></pre></div></td></tr></table></figure><p>账页信息和 Hash 值组合在一起就构成了第一个区块。</p><blockquote><p>比特币系统里约 10 分钟记一次账，即每个区块生成时间大概间隔 10 分钟</p></blockquote><p>在记第 2 个账页的时候，会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash, 即：</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Hash</span><span class="hljs-params">(上一个Hash值、序号<span class="hljs-number">1</span>、记账时间、交易记录)</span></span> = <span class="hljs-number">456635</span>BCD<br></code></pre></div></td></tr></table></figure><p>这样第 2 个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。</p><p>所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的 Hash 值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的 Hash 值发生变化，这样在验证时就无法通过）的总账本。</p>]]></content>
    
    
    <categories>
      
      <category>block_chain</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>什么是比特币</title>
    <link href="/2019/11/02/block_chain/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    <url>/2019/11/02/block_chain/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AF%94%E7%89%B9%E5%B8%81/</url>
    
    <content type="html"><![CDATA[<h3 id="比特币是什么"><a href="#比特币是什么" class="headerlink" title="比特币是什么"></a>比特币是什么</h3><blockquote><p>比特币是一种基于分布式网络的数字货币。<br>比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。</p></blockquote><p>本文主要讲解狭义的比特币概念。</p><h3 id="数字货币是什么"><a href="#数字货币是什么" class="headerlink" title="数字货币是什么"></a>数字货币是什么</h3><p>凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币）</p><h3 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h3><p>大家知道，在银行系统的数据库里记录着跟我们身份 id 对应的财产，下文称这样的记录为账本，如张三的卡 10 月 1 日转入 1w, 余额 10w。<br>比特币系统也同样有这样的账本，不同银行由单一的组织负责记录，比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。<br>同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从 1 万改为 1 百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。</p>]]></content>
    
    
    <categories>
      
      <category>block_chain</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
